_________________________________________________________________
Лаба 2


LD_LIBRARY_PATH, в которой перечисляются все каталоги содержащие пользовательские динамические библиотеки
 чтобы переходы в функциях библиотеки (операции goto на ассемблере) использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе gcc данная возможность включается ключом -fPIC. 

Динамическая библиотека это уже не архивный файл, а настоящая загружаемая программа, поэтому созданием динамических библиотек занимается сам компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared: 

-c используется для процесса компиляции/ создать объектный файл
-o для компоновки /создать загрузычный файл
-l library	использовать библиотеку library.a при редактировании связей
-I dir 	добавить каталог dir в список поиска каталогов, содержащих include- файлы 
-L dir 	добавить директорию dir в список поиска библиотекки


Стек - это память, выделенная как пустое место для потока выполнения. Когда вызывается функция, блок резервируется в верхней части стека для локальных переменных и некоторых данных учета. Когда эта функция возвращается, блок становится неиспользуемым и может использоваться при следующем вызове функции. Стек всегда зарезервирован в порядке LIFO (последний в порядке очереди); последний зарезервированный блок всегда является следующим блоком, который должен быть освобожден. Это действительно упрощает отслеживание стека; освобождение блока из стека - это не более, чем настройка одного указателя.

Куча памяти выделяется для динамического выделения. В отличие от стека, нет принудительного шаблона для выделения и освобождения блоков из кучи; Вы можете выделить блок в любое время и освободить его в любое время. Это значительно усложняет отслеживание того, какие части кучи выделены или свободны в любой момент времени; Есть много пользовательских распределителей кучи, доступных для настройки производительности кучи для различных моделей использования.

Каждый поток получает стек, в то время как для приложения обычно есть только одна куча (хотя весьма часто иметь несколько куч для разных типов размещения).

Чтобы ответить на ваши вопросы напрямую:

    В какой степени они контролируются ОС или языковой средой выполнения?

ОС выделяет стек для каждого потока системного уровня при его создании. Обычно ОС вызывается языковой средой выполнения для выделения кучи для приложения.

    Какова их сфера применения?

Стек присоединен к потоку, поэтому, когда поток выходит из стека, он освобождается. Куча обычно выделяется при запуске приложения средой выполнения и восстанавливается при выходе из приложения (технически процесса).

    От чего зависит размер каждого из них?

Размер стека устанавливается при создании потока. Размер кучи устанавливается при запуске приложения, но может увеличиваться по мере необходимости (распределитель запрашивает больше памяти у операционной системы).

    Что делает быстрее?

Стек работает быстрее, потому что шаблон доступа упрощает выделение и освобождение памяти из него (указатель / целое число просто увеличивается или уменьшается), в то время как куча имеет гораздо более сложную бухгалтерию, связанную с выделением или освобождением. Кроме того, каждый байт в стеке имеет тенденцию использоваться очень часто, что означает, что он имеет тенденцию отображаться в кэш процессора, что делает его очень быстрым. Еще одним ударом по производительности для кучи является то, что куча, являющаяся главным образом глобальным ресурсом, как правило, должна быть многопоточной безопасной, то есть каждое распределение и освобождение должны быть - как правило - синхронизированы со «всеми» другими обращениями к куче в программе.


Препроцессинг

Эту операцию осуществляет текстовый препроцессор.

Исходный текст частично обрабатывается — производятся:

    Замена комментариев пустыми строками
    Текстовое включение файлов — #include
    Макроподстановки — #define
    Обработка директив условной компиляции — #if, #ifdef, #elif, #else, #endif

Компиляция

Процесс компиляции состоит из следующих этапов:

    Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
    Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.
    Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
    Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
    Генерация кода. Из промежуточного представления порождается объектный код.


Результатом компиляции является объектный код.

Компоновка
Также называется связывание, сборка или линковка.

Это последний этап процесса получения исполняемого файла, состоящий из связывания воедино всех объектных файлов проекта.

При этом возможны ошибки связывания.

Если, допустим, функция была объявлена, но не определена, ошибка обнаружится только на этом этапе.


Статическая библиотека - (*.a) собрана для непосредственного встраивания в Ваш исполняемый файл. Она просто будет помещена в соответствии с указанием linker'а. Тут будет статическая линковка.

Динамическая библиотека - (*.so) - будет просто подключаться как link на референс и не попадет в Ваш бинарь. Будет лишь указание где брать референс на тот или иной функционал. Тут будет динамическая линковка
_________________________________________________________________________
Лаба 3
exec Передает исполнение программы в отдельный процесс
fork - дублирует процесс с момента его вызова
pipe создает пару файловых дескрипторов,
int pf[2]; pipe(pf); pf[1]-дескриптор ввода/записи pf[0]-дескриптор вывода/чтения
---------------------------------------------------------------------
Лаба 4
 Функция `kill` - посылает сигнал процессу, либо группе процессов 
int kill(pid_t pid, int sig);
 Если значение pid является положительным, сигнал sig посылается процессу с идентификатором pid.

Если pid равен 0, то sig посылается каждому процессу, который входит в группу текущего процесса.

Если pid равен -1, то sig посылается каждому процессу, за исключением процесса с номером 1 (init), но есть нюансы, которые описываются ниже.

Если pid меньше чем -1, то sig посылается каждому процессу, который входит в группу процесса -pid.

Если sig равен 0, то никакой сигнал не посылается, а только выполняется проверка на ошибку.

alarm() - Посылает сигнал SIGALRM процессу его вызвавшему. 
signal(sig, sig_handler) позволяет вызвать обработчик сигналов (sig_handler), когда будет вызван сигнал sig. 


WNOHANG
    означает немедленное возвращение управления, если ни один дочерний процесс не завершил выполнение.

Процессы-зомби появляются когда, дочерний процесс завершил выполнение, но родительский процесс его не обработал. Процессы зомби не занимают памяти, а занимают место для процесса,в следствие чего невозможно будет создать новые процессы. Так как зомби процессы завершили свое выполнение то их нельзя "убить". Поэтому чтобы избавиться от зомби-процессов родительский процесс должен периодически вызывать команду wait(), которая посылает процессу-родителю сигнал SIGCHLD от дочернего процесса сообщающий о завершении его завершении.


`etext`, `edata`, `end`. - Адреса этих символов описывают конец определенных сегментов. 
`etext`- Описывает первый адрес после конца кода
`edata`- Описывает первый адресс после конца иничиализированных данных
`end`- Описывает первый адресс после конца неинициализированных данных

Вся память разбивается на сегменты. Когда запускается процесс создается виртуальная память, для того чтобы один процесс не смогу обратиться в область памят другого процесса. Если такое происходит, то выдается ошибка segmetation fault 

Поток это часть процесса использующая ту или иную часть сегмента данных.
Польза потоков в том, что создание нового потока происходит быстрее чем создание нового процесса так как процессы создают копии всех данных или в случае exec все эти данные передаются в новые процесс, что очень расточительно. Потоки же используют уже созданные данные.

